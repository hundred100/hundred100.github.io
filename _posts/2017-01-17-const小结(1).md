---
layout:     post   				    # 使用的布局（不需要改）
title:     C/C++|const限定符小结（一）				# 标题 
subtitle:   C/C++|const限定符小结（一） #副标题
date:       2017-01-17 				# 时间
author:     hundred 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 总结
---
#C/C++|const限定符小结（一）
##一、概述

用const限定来限定值不能被改变的变量。一个变量被const限定后，值不能被改变，只能在const类型的对象上执行不改变其内容的操作。

默认状态下，const对象仅在文件内有效，若要在多个文件内共享该对象，可以只在一个文件中定义const，而在多个文件中声明并使用它。此时，对于const变量，不管是声明还是定义，都添加extern关键字。

>//file1.cpp定义并初始化一个常量，该常量能被其他文件访问
>
extern const int a=1;
>
//file1.h头文件
>
extern const int a;//与file1.cpp中定义的a是同一个

##二、const的引用

可以把引用绑定到const对象上，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。

>const int b=2017;
>
const int &r=b;//正确，引用及其对应的对象都是常量
>
r=27;//错误，r是一个对常量的引用
>
int &r1=b;//错误，视图让一个非常量引用指向一个常量对象

因为不允许直接为b赋值，因此也不能通过引用去改变b。因此，对r1的初始化是错的。

####对const的引用可能引用一个非const的对象

对const 的引用可以引用一个非const的对象，但是不能通过对const的引用来改变这个非const       对象，但是可以通过其他途径来改变这个被引用的非const对象。

>int i=25;//非const的对象
>
int &r1=i;//r1引用i
>
const int &r2=i;//r2是对const的引用，也引用非const对象i
>
r1=1;//正确，r1非常量，值可以变
>
r2=1;//错误，r2是一个对常量的引用，值不可变

r2可以引用非const对象i，但是，r2是对常量的引用，因此不能通过r2来改变i的值，不过可以通过其他途径来改变i的值。

##三、指针和const

####指向常量的指针

类似常量引用，指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能用指向常量的指针：

>const double pi=3.14;//pi是个常量，它的值不能改变
>
double *ptr=&pi;//错误：ptr是一个普通指针
>
const double *cptr=&pi;//正确：cptr可以指向一个双精度常量
>
*cptr=42;//错误：不能给*cptr赋值

######*和对常量的引用一样，指向常量的指针也可以指向一个非常量对象。*

>###综上：
######*指针/引用所指向/引用的对象是常量（const修饰）对象时，其本身必须是一个指向常量的指针/对常量的引用（const修饰）。但是，指向常量的指针/对常量的引用也可以指向/引用没有const修饰的普通对象，即不能通过该指针/引用改变对象的值，但可以通过其他途径改变对象值。*

####const指针
指针是对象，因此可以把指针本身定为常量，称为常量指针。常量指针必须初始化，一旦初始化完成，它的值（存放在指针中的地址）无法再改变。

声明常量指针，是把*放在const关键字之前，用以说明指针是一个常量，不变的是指针本 身的值而非指向的那个值。

####常量指针和指向常量的指针:

常量指针和指向常量的指针不同。常量指针是把*放在const之前，表示指针是个常量，就是指针本身的值不变，也就是存放在指针中的地址不变，但其指向的对象值可以通过该指针改变；而指向常量的指针是把*放在const之后，可以指向常量对象也可以指向普通对象，指针本身的值可以改变，存放在指针中的地址可以改变，但是其指向的对象不能通过该指针改变值。当指向常量对象时，必须用指向常量的指针。

>int errNumb=0;
>
int errNumb1=2;
>
int *const curErr=&errNumb;//常量指针,curErr的值为&errNumb不变,即一直指向&errNumb
>
curErr=&errNumb1;//错误：curErr是常量，值不能变
>
*curErr=2;//正确：curErr指向的对象值可通过它改变
>
const double pi=3.14159;//常量
>
const double pi1=2.1412;
>
const double *pip1=&pi;//pip1是指向常量的指针
>
*pip1=2.1412;//错误：pi的值不能通过pip1改变
>
pip1=&pi1;//正确：pip1本身的值可以改变
>
const double *const pip=&pi;//pip是一个指向常量对象的常量指针

##四、顶层const和底层const
 如前面所述，const遇到指针，有两种情况，分别是常量指针和指向常量的指针。两者的区别是，常量指针是指针本身是一个常量，指向常量的指针是指针所指向的对象是个常量，不能改变所指向对象的值。

顶层const表示对象本身是个常量，如常量指针是顶层const，底层const表示指针所指的 对象或者引用所引用的对象是个常量，如指向常量的指针是个底层const。

顶层const可表示任意对象是常量，底层const则与指针和引用等符合类型的基本类型部分有关。

####用于声明引用的const都是底层const。

>int i=0;
>
int *const p1=&i;//顶层const，p1是个常量
>
const int ci=42;//顶层const，ci是个常量
>
const int *p2=&ci;//底层const，p2所指的对象是个常量
>
const int *const p3=p2;//靠右的const是顶层const，靠左的是底层const
>
const int &r=ci;//用于声明引用的const都是底层const

当执行拷贝操作时，常量是顶层const还是底层const区别明显。其中，顶层const不受什么影响：

*（继续上一个例子）*

>i=ci;//正确：拷贝ci的值，ci是一个顶层const，对此操作无影响
>
p2=p3;//正确：p2和p3指向的对象类型相同，p3顶层const部分不受影响

底层const的限制却不能忽视。当执行对象的拷贝操作时，考入和拷出的对象必须具有相同        的底层const资格，或者两个对象的数据类型必须能转化。一般来说，非常量可以转换成常量，        反之不行：

*(继续上一个)*

>int *p=p3;//错误：p3包含底层const的定义，而p没有
>
p2=p3;//正确：p2和p3都是底层const
>
p2=&i;//正确：int*能转换成const int*
>
int &r=ci;//错误：普通的int&不能绑定到int常量上
>
const int &r2=i;//正确：const int&可以绑定到一个普通int上

其实底层const的拷贝规则就是前面对常量的引用和指向常量的指针的拷贝规则，不理解的可以参照前面。

以上内容参考自《C++ primer(第五版)》,欢迎给出建议和批评。
